<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="?WHd#*g6(y@I8(cqrPVz" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="=TwicXg]X6oOG@1MuX)p" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace lineTracingForPowerbrick {" line1="" line2="    const PCA9685_ADDRESS = 0x40" line3="    const MODE1 = 0x00" line4="    const MODE2 = 0x01" line5="    const SUBADR1 = 0x02" line6="    const SUBADR2 = 0x03" line7="    const SUBADR3 = 0x04" line8="    const PRESCALE = 0xFE" line9="    const LED0_ON_L = 0x06" line10="    const LED0_ON_H = 0x07" line11="    const LED0_OFF_L = 0x08" line12="    const LED0_OFF_H = 0x09" line13="    const ALL_LED_ON_L = 0xFA" line14="    const ALL_LED_ON_H = 0xFB" line15="    const ALL_LED_OFF_L = 0xFC" line16="    const ALL_LED_OFF_H = 0xFD" line17="" line18="    let initialized = false" line19="" line20="    const PortDigi = [" line21="        [DigitalPin.P8, DigitalPin.P0]," line22="        [DigitalPin.P12, DigitalPin.P1]," line23="        [DigitalPin.P13, DigitalPin.P2]," line24="        [DigitalPin.P15, DigitalPin.P14]," line25="        [DigitalPin.P6, DigitalPin.P3]," line26="        [DigitalPin.P7, DigitalPin.P4]," line27="        [DigitalPin.P9, DigitalPin.P10]" line28="    ]" line29="" line30="    export enum Ports {" line31="        PORT1 = 0," line32="        PORT2 = 1," line33="        PORT3 = 2," line34="        PORT4 = 3," line35="        PORT5 = 4," line36="        PORT6 = 5," line37="        PORT7 = 6" line38="    }" line39="" line40="    export enum Slots {" line41="        A = 1, // inverse slot by zp" line42="        B = 0" line43="    }" line44="" line45="    export enum Motors {" line46="        M1 = 0x1," line47="        M2 = 0x2" line48="    }" line49="" line50="    function i2cwrite(addr: number, reg: number, value: number) {" line51="        let buf = pins.createBuffer(2)" line52="        buf[0] = reg" line53="        buf[1] = value" line54="        pins.i2cWriteBuffer(addr, buf)" line55="    }" line56="" line57="    function i2ccmd(addr: number, value: number) {" line58="        let buf2 = pins.createBuffer(1)" line59="        buf2[0] = value" line60="        pins.i2cWriteBuffer(addr, buf2)" line61="    }" line62="" line63="" line64="    function i2cread(addr: number, reg: number) {" line65="        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);" line66="        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);" line67="        return val;" line68="    }" line69="" line70="    function setFreq(freq: number): void {" line71="        // Constrain the frequency" line72="        let prescaleval = 25000000;" line73="        prescaleval /= 4096;" line74="        prescaleval /= freq;" line75="        prescaleval -= 1;" line76="        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);" line77="        let oldmode = i2cread(PCA9685_ADDRESS, MODE1);" line78="        let newmode = (oldmode &amp; 0x7F) | 0x10; // sleep" line79="        i2cwrite(PCA9685_ADDRESS, MODE1, newmode); // go to sleep" line80="        i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler" line81="        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);" line82="        control.waitMicros(5000);" line83="        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);" line84="    }" line85="" line86="    function setPwm(channel: number, on: number, off: number): void {" line87="        if (channel &lt; 0 || channel &gt; 15)" line88="            return;" line89="        let buf3 = pins.createBuffer(5);" line90="        buf3[0] = LED0_ON_L + 4 * channel;" line91="        buf3[1] = on &amp; 0xff;" line92="        buf3[2] = (on &gt;&gt; 8) &amp; 0xff;" line93="        buf3[3] = off &amp; 0xff;" line94="        buf3[4] = (off &gt;&gt; 8) &amp; 0xff;" line95="        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf3);" line96="    }" line97="" line98="    function initPCA9685(): void {" line99="        i2cwrite(PCA9685_ADDRESS, MODE1, 0x00)" line100="        setFreq(50);" line101="        for (let idx = 0; idx &lt; 16; idx++) {" line102="            setPwm(idx, 0, 0);" line103="        }" line104="        initialized = true" line105="    }" line106="" line107="    export function MotorRun(index: Motors, speed: number): void {" line108="        if (!initialized) {" line109="            initPCA9685()" line110="        }" line111="        speed = speed * 16; // map 255 to 4096" line112="        if (speed &gt;= 4096) {" line113="            speed = 4095" line114="        }" line115="        if (speed &lt;= -4096) {" line116="            speed = -4095" line117="        }" line118="        if (index &gt; 2 || index &lt;= 0)" line119="            return" line120="        let pp = (index - 1) * 2" line121="        let pn = (index - 1) * 2 + 1" line122="        // serial.writeString(&quot;M &quot; + index + &quot; spd &quot; + speed + &quot; pp &quot; + pp + &quot; pn &quot; + pn + &quot;\n&quot;)" line123="        if (speed &gt;= 0) {" line124="            setPwm(pp, 0, speed)" line125="            setPwm(pn, 0, 0)" line126="        } else {" line127="            setPwm(pp, 0, 0)" line128="            setPwm(pn, 0, -speed)" line129="        }" line130="    }" line131="" line132="    //blockId=haha block=&quot;HaHa|huhu %hehe|huhu %hihi&quot;" line133="    //% group=&quot;gaga&quot; weight=81" line134="    export function HaHa(hehe:string, hihi:string): void{" line135="" line136="    }" line137="" line138="" line139="    //% blockId=custom_motor_dual block=&quot;Motor|speed %speed1|speed %speed2&quot;" line140="    //% weight=43" line141="    //% speed1.min=-255 speed1.max=255" line142="    //% speed2.min=-255 speed2.max=255" line143="    //% group=&quot;Actuator&quot; name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=4" line144="    export function MotorRunDual(speed1: number, speed2: number): void {" line145="        MotorRun(1, speed1);" line146="        MotorRun(2, speed2);" line147="    }" line148="" line149="    //% blockId=custom_tracer block=&quot;Tracer|port %port|slot %slot&quot;" line150="    //% group=&quot;Linefollower&quot; weight=81" line151="    export function Tracer(port: Ports, slot: Slots): boolean {" line152="        let pin = PortDigi[port][slot]" line153="        pins.setPull(pin, PinPullMode.PullUp)" line154="        return pins.digitalReadPin(pin) == 1" line155="    }" line156="" line157="    //% blockId=custom_tracing_line_with_motors block=&quot;MoveAlongBlackLine|port %port|speed %speed&quot;" line158="    //% speed.min=-255 speed.max=255" line159="    export function TracingLineWithMotors(port: Ports, speed: number): void {" line160="        if (Tracer(port, Slots.A) &amp;&amp; Tracer(port, Slots.B)) {" line161="            MotorRunDual(speed, speed)" line162="        } else if (!(Tracer(port, Slots.A)) &amp;&amp; Tracer(port, Slots.B)) {" line163="            MotorRunDual(speed, -speed)" line164="        } else if (Tracer(port, Slots.A) &amp;&amp; !(Tracer(port, Slots.B))) {" line165="            MotorRunDual(-speed, speed)" line166="        } else if (!(Tracer(port, Slots.A)) &amp;&amp; !(Tracer(port, Slots.B))) {" line167="            MotorRunDual(-speed, -speed)" line168="        }" line169="    }" line170="}" numlines="171"></mutation></block></statement></block></xml>