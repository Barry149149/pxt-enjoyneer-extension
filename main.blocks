<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="_kw`^(KIGw7~_+l4BuAh" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="eB`o.uMgKx9PC~WN8EEw" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace lineTracingForPowerbrick {" line1="" line2="    const PCA9685_ADDRESS = 0x40" line3="    const MODE1 = 0x00" line4="    const MODE2 = 0x01" line5="    const SUBADR1 = 0x02" line6="    const SUBADR2 = 0x03" line7="    const SUBADR3 = 0x04" line8="    const PRESCALE = 0xFE" line9="    const LED0_ON_L = 0x06" line10="    const LED0_ON_H = 0x07" line11="    const LED0_OFF_L = 0x08" line12="    const LED0_OFF_H = 0x09" line13="    const ALL_LED_ON_L = 0xFA" line14="    const ALL_LED_ON_H = 0xFB" line15="    const ALL_LED_OFF_L = 0xFC" line16="    const ALL_LED_OFF_H = 0xFD" line17="" line18="    let initialized = false" line19="" line20="    const PortDigi = [" line21="        [DigitalPin.P8, DigitalPin.P0]," line22="        [DigitalPin.P12, DigitalPin.P1]," line23="        [DigitalPin.P13, DigitalPin.P2]," line24="        [DigitalPin.P15, DigitalPin.P14]," line25="        [DigitalPin.P6, DigitalPin.P3]," line26="        [DigitalPin.P7, DigitalPin.P4]," line27="        [DigitalPin.P9, DigitalPin.P10]" line28="    ]" line29="" line30="    export enum Ports {" line31="        PORT1 = 0," line32="        PORT2 = 1," line33="        PORT3 = 2," line34="        PORT4 = 3," line35="        PORT5 = 4," line36="        PORT6 = 5," line37="        PORT7 = 6" line38="    }" line39="" line40="    export enum Slots {" line41="        A = 1, // inverse slot by zp" line42="        B = 0" line43="    }" line44="" line45="    export enum Motors {" line46="        M1 = 0x1," line47="        M2 = 0x2" line48="    }" line49="" line50="    function i2cwrite(addr: number, reg: number, value: number) {" line51="        let buf = pins.createBuffer(2)" line52="        buf[0] = reg" line53="        buf[1] = value" line54="        pins.i2cWriteBuffer(addr, buf)" line55="    }" line56="" line57="    function i2ccmd(addr: number, value: number) {" line58="        let buf2 = pins.createBuffer(1)" line59="        buf2[0] = value" line60="        pins.i2cWriteBuffer(addr, buf2)" line61="    }" line62="" line63="" line64="    function i2cread(addr: number, reg: number) {" line65="        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);" line66="        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);" line67="        return val;" line68="    }" line69="" line70="    function setFreq(freq: number): void {" line71="        // Constrain the frequency" line72="        let prescaleval = 25000000;" line73="        prescaleval /= 4096;" line74="        prescaleval /= freq;" line75="        prescaleval -= 1;" line76="        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);" line77="        let oldmode = i2cread(PCA9685_ADDRESS, MODE1);" line78="        let newmode = (oldmode &amp; 0x7F) | 0x10; // sleep" line79="        i2cwrite(PCA9685_ADDRESS, MODE1, newmode); // go to sleep" line80="        i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler" line81="        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);" line82="        control.waitMicros(5000);" line83="        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);" line84="    }" line85="" line86="    function setPwm(channel: number, on: number, off: number): void {" line87="        if (channel &lt; 0 || channel &gt; 15)" line88="            return;" line89="        let buf3 = pins.createBuffer(5);" line90="        buf3[0] = LED0_ON_L + 4 * channel;" line91="        buf3[1] = on &amp; 0xff;" line92="        buf3[2] = (on &gt;&gt; 8) &amp; 0xff;" line93="        buf3[3] = off &amp; 0xff;" line94="        buf3[4] = (off &gt;&gt; 8) &amp; 0xff;" line95="        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf3);" line96="    }" line97="" line98="    function initPCA9685(): void {" line99="        i2cwrite(PCA9685_ADDRESS, MODE1, 0x00)" line100="        setFreq(50);" line101="        for (let idx = 0; idx &lt; 16; idx++) {" line102="            setPwm(idx, 0, 0);" line103="        }" line104="        initialized = true" line105="    }" line106="" line107="    export function MotorRun(index: Motors, speed: number): void {" line108="        if (!initialized) {" line109="            initPCA9685()" line110="        }" line111="        speed = speed * 16; // map 255 to 4096" line112="        if (speed &gt;= 4096) {" line113="            speed = 4095" line114="        }" line115="        if (speed &lt;= -4096) {" line116="            speed = -4095" line117="        }" line118="        if (index &gt; 2 || index &lt;= 0)" line119="            return" line120="        let pp = (index - 1) * 2" line121="        let pn = (index - 1) * 2 + 1" line122="        // serial.writeString(&quot;M &quot; + index + &quot; spd &quot; + speed + &quot; pp &quot; + pp + &quot; pn &quot; + pn + &quot;\n&quot;)" line123="        if (speed &gt;= 0) {" line124="            setPwm(pp, 0, speed)" line125="            setPwm(pn, 0, 0)" line126="        } else {" line127="            setPwm(pp, 0, 0)" line128="            setPwm(pn, 0, -speed)" line129="        }" line130="    }" line131="" line132="" line133="    //% blockId=custom_motor_dual block=&quot;Motor|speed %speed1|speed %speed2&quot;" line134="    //% weight=43" line135="    //% speed1.min=-255 speed1.max=255" line136="    //% speed2.min=-255 speed2.max=255" line137="    //% group=&quot;Actuator&quot; name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=4" line138="    export function MotorRunDual(speed1: number, speed2: number): void {" line139="        MotorRun(1, speed1);" line140="        MotorRun(2, speed2);" line141="    }" line142="" line143="    //% blockId=custom_tracer block=&quot;Tracer|port %port|slot %slot&quot;" line144="    //% group=&quot;Linefollower&quot; weight=81" line145="    export function Tracer(port: Ports, slot: Slots): boolean {" line146="        let pin = PortDigi[port][slot]" line147="        pins.setPull(pin, PinPullMode.PullUp)" line148="        return pins.digitalReadPin(pin) == 1" line149="    }" line150="" line151="    //% blockId=custom_tracing_line_with_motors block=&quot;MoveAlongBlackLine|port %port|speed %speed&quot;" line152="    //% speed.min=-255 speed.max=255" line153="    export function TracingLineWithMotors(port: Ports, speed: number): void {" line154="        if (Tracer(port, Slots.A) &amp;&amp; Tracer(port, Slots.B)) {" line155="            MotorRunDual(speed, speed)" line156="        } else if (!(Tracer(port, Slots.A)) &amp;&amp; Tracer(port, Slots.B)) {" line157="            MotorRunDual(speed, -speed)" line158="        } else if (Tracer(port, Slots.A) &amp;&amp; !(Tracer(port, Slots.B))) {" line159="            MotorRunDual(-speed, speed)" line160="        } else if (!(Tracer(port, Slots.A)) &amp;&amp; !(Tracer(port, Slots.B))) {" line161="            MotorRunDual(-speed, -speed)" line162="        }" line163="    }" line164="}" numlines="165"></mutation></block></statement></block></xml>